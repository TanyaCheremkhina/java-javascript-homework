(defn expression [func] (fn [& args] (fn [values] (apply func (mapv (fn [i] (i values)) args)))))
(defn constant [x] (fn [values] x))
(defn variable [x] (fn [values] (get values x)))
(def add (expression +))
(def subtract (expression -))
(def negate (expression -))
(def multiply (expression *))
(def med (expression (fn [& args] (nth (sort args) (long (/ (count args) 2))))))
(def avg (expression (fn [& args] (/ (apply + args) (count args) ))) )
(defn divide [a b] (fn [values] (/ (double (a values)) (b values))))
(def oper {'+ add '- subtract '* multiply '/ divide 'negate negate 'med med 'avg avg})
(def vars {'x "x" 'y "y" 'z "z"})
(defn parse [args] (cond
    (= (type args) clojure.lang.PersistentList)
    (let [newArgs (mapv (fn [i] (parse i)) (drop 1 args))
          exp (get oper (first args))] (apply exp newArgs))
    (isa? (type args) Number) (constant args)
    :else (variable (get vars args)))
)
(defn parseFunction [input] (parse (read-string input)))
